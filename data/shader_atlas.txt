//example of some shaders compiled
flat basic.vs flat.fs
texture basic.vs texture.fs
depth quad.vs depth.fs
multi basic.vs multi.fs
shadowmap basic.vs shadowmap.fs
normals basic.vs normals.fs
uvs basic.vs uvs.fs
// FORWARD
singlelight basic.vs singlelight.fs
multilight basic.vs multilight.fs
// DEFERRED
gbuffers basic.vs gbuffers.fs
deferred quad.vs deferred.fs
// SSAO
ssao quad.vs ssao.fs
ssao_plus quad.vs ssao_plus.fs
ssao_blur quad.vs ssao_blur.fs
// HDR - TONEMAPPING
tonemapping quad.vs tonemapping.fs
//PROBE - IRRADIANCE
probe basic.vs probe.fs
irradiance quad.vs irradiance.fs
//SKYBOX - REFLECTION
skybox basic.vs skybox.fs
reflection_probe basic.vs reflection_probe.fs
//VOLUMETRIC - DECALS
volumetric quad.vs volumetric.fs
decal basic.vs decal.fs
//POSTFX
greyscale quad.vs greyscale.fs
contrast quad.vs contrast.fs
blur quad.vs blur.fs
mix quad.vs mix.fs
threshold quad.vs threshold.fs
dof quad.vs dof.fs
bloom quad.vs bloom.fs
fxaa quad.vs fxaa.fs
lut quad.vs lut.fs
lens_distortion quad.vs lens_distortion.fs
chromatic_aberration quad.vs chromatic_aberration.fs
motionblur quad.vs motionblur.fs
grain quad.vs grain.fs
pixelization quad.vs pixelization.fs

\blurtex
#define Pi 6.28318530718

// GAUSSIAN BLUR SETTINGS {{{
#define directions 16.0 // BLUR DIRECTIONS (Default 16.0 - More is better but slower)
#define quality 3.0 // BLUR QUALITY (Default 4.0 - More is better but slower)
// GAUSSIAN BLUR SETTINGS }}}

vec4 blur_texture(sampler2D texture_blur, vec2 iRes, float size)
{
	vec2 radius = size * iRes.xy;
  
	// Normalized pixel coordinates (from 0 to 1)
	vec2 uv = gl_FragCoord.xy * iRes.xy;
	// Pixel colour
	vec4 color = texture( texture_blur, uv);
  
	// Blur calculations
	for( float d = 0.0; d < Pi; d += Pi/directions)
	{
		for(float i=1.0/quality; i<=1.0; i+=1.0/quality)
		{
			color += texture( texture_blur, uv+vec2(cos(d),sin(d))*radius*i);
		}
	}
  
  // Output to screen
  color /= quality * directions + 10.0;
  return color;
}

\normal_func
mat3 cotangent_frame(vec3 N, vec3 p, vec2 uv)
{
	// get edge vectors of the pixel triangle
	vec3 dp1 = dFdx( p );
	vec3 dp2 = dFdy( p );
	vec2 duv1 = dFdx( uv );
	vec2 duv2 = dFdy( uv );
	
	// solve the linear system
	vec3 dp2perp = cross( dp2, N );
	vec3 dp1perp = cross( N, dp1 );
	vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
	vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;
 
	// construct a scale-invariant frame 
	float invmax = inversesqrt( max( dot(T,T), dot(B,B) ) );
	return mat3( T * invmax, B * invmax, N );
}

// assume N, the interpolated vertex normal and 
// WP the world position
//vec3 normal_pixel = texture2D( normalmap, uv ).xyz; 
vec3 perturbNormal(vec3 N, vec3 WP, vec2 uv, vec3 normal_pixel)
{
	normal_pixel = normal_pixel * 255./127. - 128./127.;
	mat3 TBN = cotangent_frame(N, WP, uv);
	return normalize(TBN * normal_pixel);
}

\getConeFactor

float getConeFactor (vec3 L)
{
	float spot_cosine = dot(u_light_position, -L);
	if (u_light_cone_exp.z > spot_cosine)
		return 0.0;
	return pow(spot_cosine, u_light_cone_exp.y);
}

\PBR

#define RECIPROCAL_PI 0.3183098861837697
const float PI = 3.14159265358979323846;

// Fresnel term with scalar optimization(f90=1)
float F_Schlickf90( const in float VoH, const in float f0, float f90)
{
	float f = pow(1.0 - VoH, 5.0);
	return f0 + (f90 - f0) * f;
}

// Fresnel term with colorized fresnel
vec3 F_Schlick( const in float VoH, const in vec3 f0)
{
	float f = pow(1.0 - VoH, 5.0);
	return f0 + (vec3(1.0) - f0) * f;
}

// Diffuse Reflections: Disney BRDF using retro-reflections using F term, this is much more complex!!
float Fd_Burley ( const in float NoV, const in float NoL, const in float LoH, const in float linearRoughness)
{
        float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;
        float lightScatter = F_Schlickf90(NoL, 1.0, f90);
        float viewScatter  = F_Schlickf90(NoV, 1.0, f90);
        return lightScatter * viewScatter * RECIPROCAL_PI;
}

// Normal Distribution Function using GGX Distribution
float D_GGX (	const in float NoH, const in float linearRoughness )
{
	float a2 = linearRoughness * linearRoughness;
	float f = (NoH * NoH) * (a2 - 1.0) + 1.0;
	return a2 / (PI * f * f);
}

// Geometry Term: Geometry masking/shadowing due to microfacets
float GGX(float NdotV, float k){
	return NdotV / (NdotV * (1.0 - k) + k);
}
	
float G_Smith( float NdotV, float NdotL, float roughness)
{
	float k = pow(roughness + 1.0, 2.0) / 8.0;
	return GGX(NdotL, k) * GGX(NdotV, k);
}

//this is the cook torrance specular reflection model
vec3 specularBRDF( float roughness, vec3 f0, float NoH, float NoV, float NoL, float LoH )
{
	float a = roughness * roughness;

	// Normal Distribution Function
	float D = D_GGX( NoH, a );

	// Fresnel Function
	vec3 F = F_Schlick( LoH, f0 );

	// Visibility Function (shadowing/masking)
	float G = G_Smith( NoV, NoL, roughness );

	// Norm factor
	vec3 spec = D * G * F;
	spec /= (4.0 * NoL * NoV + 1e-6);

	return spec;
}

\linear_space

vec3 degamma(vec3 c) { return pow(c,vec3(2.2)); }

vec3 gamma(vec3 c){ return pow(c,vec3(1.0/2.2)); }

\SH
const float Pi = 3.141592654;
const float CosineA0 = Pi;
const float CosineA1 = (2.0 * Pi) / 3.0;
const float CosineA2 = Pi * 0.25;
struct SH9 { float c[9]; }; //to store weights
struct SH9Color { vec3 c[9]; }; //to store colors

void SHCosineLobe(in vec3 dir, out SH9 sh) //SH9
{
	// Band 0
	sh.c[0] = 0.282095 * CosineA0;
	// Band 1
	sh.c[1] = 0.488603 * dir.y * CosineA1; 
	sh.c[2] = 0.488603 * dir.z * CosineA1;
	sh.c[3] = 0.488603 * dir.x * CosineA1;
	// Band 2
	sh.c[4] = 1.092548 * dir.x * dir.y * CosineA2;
	sh.c[5] = 1.092548 * dir.y * dir.z * CosineA2;
	sh.c[6] = 0.315392 * (3.0 * dir.z * dir.z - 1.0) * CosineA2;
	sh.c[7] = 1.092548 * dir.x * dir.z * CosineA2;
	sh.c[8] = 0.546274 * (dir.x * dir.x - dir.y * dir.y) * CosineA2;
}

vec3 ComputeSHIrradiance(in vec3 normal, in SH9Color sh)
{
	// Compute the cosine lobe in SH, oriented about the normal direction
	SH9 shCosine;
	SHCosineLobe(normal, shCosine);
	// Compute the SH dot product to get irradiance
	vec3 irradiance = vec3(0.0);
	for(int i = 0; i < 9; ++i)
		irradiance += sh.c[i] * shCosine.c[i];

	return irradiance;
}

\irradiance

vec3 computeIrr(vec3 local_indices, vec3 N, vec3 irr_dims, float num_probes, sampler2D probes_texture){
	//compute in which row is the probe stored
	float row = local_indices.x + local_indices.y * irr_dims.x + local_indices.z * irr_dims.x * irr_dims.y;

	//find the UV.y coord of that row in the probes texture
	float row_uv = (row + 1.0) / (num_probes + 1.0);
	
	SH9Color sh;
	
	//fill the coefficients
	const float d_uvx = 1.0 / 9.0;
	for(int i = 0; i < 9; ++i)
	{
		vec2 coeffs_uv = vec2( (float(i)+0.5) * d_uvx, row_uv );
		sh.c[i] = texture( probes_texture, coeffs_uv).xyz;
	}

	//now we can use the coefficients to compute the irradiance
	vec3 irradiance = ComputeSHIrradiance( N, sh );

	return irradiance;
}

vec3 computeIrradiance(vec3 irr_end, vec3 irr_start, vec3 worldpos, vec3 N, float irr_normal_distance, vec3 irr_delta, vec3 irr_dims, float num_probes, sampler2D probes_texture){
	//computing nearest probe index based on world position
	vec3 irr_range = irr_end - irr_start;
	vec3 irr_local_pos = clamp( worldpos - irr_start + N * irr_normal_distance, vec3(0.0), irr_range );

	//convert from world pos to grid pos
	vec3 irr_norm_pos = irr_local_pos / irr_delta;

	//round values as we cannot fetch between rows for now
	vec3 local_indices = floor( irr_norm_pos );
	
	//now we have the interpolation factors
	vec3 factors = irr_norm_pos - local_indices;

	//local_indices points to Left,Bottom,Far
	vec3 indicesLBF = local_indices;
	//example for right bottom far index
	vec3 indicesRBF = local_indices;
	indicesRBF.x += 1; //from left to right

	vec3 indicesLTF = local_indices;
	indicesLTF.y += 1; 
	
	vec3 indicesRTF = local_indices;
	indicesRTF.x += 1; 
	indicesRTF.y += 1; 

	vec3 indicesLBN = local_indices;
	indicesLBN.z += 1; 

	vec3 indicesRBN = local_indices;
	indicesRBN.x += 1; 
	indicesRBN.z += 1; 

	vec3 indicesLTN = local_indices;
	indicesLTN.y += 1; 
	indicesLTN.z += 1; 
	
	vec3 indicesRTN = local_indices;
	indicesRTN.x += 1; 
	indicesRTN.y += 1; 
	indicesRTN.z += 1; 

	//compute irradiance for every corner
	vec3 irrLBF = computeIrr( indicesLBF, N, irr_dims, num_probes, probes_texture);
	vec3 irrRBF = computeIrr( indicesRBF, N, irr_dims, num_probes, probes_texture);
	vec3 irrLTF = computeIrr( indicesLTF, N, irr_dims, num_probes, probes_texture);
	vec3 irrRTF = computeIrr( indicesRTF, N, irr_dims, num_probes, probes_texture);
	vec3 irrLBN = computeIrr( indicesLBN, N, irr_dims, num_probes, probes_texture);
	vec3 irrRBN = computeIrr( indicesRBN, N, irr_dims, num_probes, probes_texture);
	vec3 irrLTN = computeIrr( indicesLTN, N, irr_dims, num_probes, probes_texture);
	vec3 irrRTN = computeIrr( indicesRTN, N, irr_dims, num_probes, probes_texture);

	vec3 irrTF = mix( irrLTF, irrRTF, factors.x );
	vec3 irrBF = mix( irrLBF, irrRBF, factors.x );
	vec3 irrTN = mix( irrLTN, irrRTN, factors.x );
	vec3 irrBN = mix( irrLBN, irrRBN, factors.x );

	vec3 irrT = mix( irrTF, irrTN, factors.z );
	vec3 irrB = mix( irrBF, irrBN, factors.z );

	vec3 irr = mix( irrB, irrT, factors.y );
	
	return irr;
}

\basic.vs

#version 330 core

in vec3 a_vertex;
in vec3 a_normal;
in vec2 a_coord;
in vec4 a_color;

uniform vec3 u_camera_pos;

uniform mat4 u_model;
uniform mat4 u_viewprojection;

//this will store the color for the pixel shader
out vec3 v_position;
out vec3 v_world_position;
out vec3 v_normal;
out vec2 v_uv;
out vec4 v_color;

uniform float u_time;

void main()
{	
	//calcule the normal in camera space (the NormalMatrix is like ViewMatrix but without traslation)
	v_normal = (u_model * vec4( a_normal, 0.0) ).xyz;
	
	//calcule the vertex in object space
	v_position = a_vertex;
	v_world_position = (u_model * vec4( v_position, 1.0) ).xyz;
	
	//store the color in the varying var to use it from the pixel shader
	v_color = a_color;

	//store the texture coordinates
	v_uv = a_coord;

	//calcule the position of the vertex using the matrices
	gl_Position = u_viewprojection * vec4( v_world_position, 1.0 );
}

\quad.vs

#version 330 core

in vec3 a_vertex;
in vec2 a_coord;
out vec2 v_uv;

void main()
{	
	v_uv = a_coord;
	gl_Position = vec4( a_vertex, 1.0 );
}


\flat.fs

#version 330 core

uniform vec4 u_color;

out vec4 FragColor;

void main()
{
	FragColor = u_color;
}


\texture.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;
in vec4 v_color;

uniform vec4 u_color;
uniform sampler2D u_texture;
uniform float u_time;
uniform float u_alpha_cutoff;

out vec4 FragColor;

void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture( u_texture, v_uv );

	if(color.a < u_alpha_cutoff)
		discard;

	FragColor = color;
}

\multi.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;

uniform vec4 u_color;
uniform sampler2D u_texture;
uniform float u_time;
uniform float u_alpha_cutoff;

layout(location = 0) out vec4 FragColor;
layout(location = 1) out vec4 NormalColor;

void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture( u_texture, uv );

	if(color.a < u_alpha_cutoff)
		discard;

	vec3 N = normalize(v_normal);

	FragColor = color;
	NormalColor = vec4(N,1.0);
}


\depth.fs

#version 330 core

uniform vec2 u_camera_nearfar;
uniform sampler2D u_texture; //depth map
in vec2 v_uv;
out vec4 FragColor;

void main()
{
	float n = u_camera_nearfar.x;
	float f = u_camera_nearfar.y;
	float z = texture2D(u_texture,v_uv).x;
	if( n == 0.0 && f == 1.0)
		FragColor = vec4(z);
	else
		FragColor = vec4( n * (z + 1.0) / (f + n - z * (f - n)));
}


\instanced.vs

#version 330 core

in vec3 a_vertex;
in vec3 a_normal;
in vec2 a_coord;

in mat4 u_model;

uniform vec3 u_camera_pos;

uniform mat4 u_viewprojection;

//this will store the color for the pixel shader
out vec3 v_position;
out vec3 v_world_position;
out vec3 v_normal;
out vec2 v_uv;

void main()
{	
	//calcule the normal in camera space (the NormalMatrix is like ViewMatrix but without traslation)
	v_normal = (u_model * vec4( a_normal, 0.0) ).xyz;
	
	//calcule the vertex in object space
	v_position = a_vertex;
	v_world_position = (u_model * vec4( a_vertex, 1.0) ).xyz;
	
	//store the texture coordinates
	v_uv = a_coord;

	//calcule the position of the vertex using the matrices
	gl_Position = u_viewprojection * vec4( v_world_position, 1.0 );
}

\normals.fs

#version 330 core

in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;

uniform vec3 u_camera_pos;
uniform sampler2D u_texture_normals;

out vec4 FragColor;

#include "normal_func"

void main()
{
	vec2 uv = v_uv;
	vec3 normal_pixel = texture2D( u_texture_normals, uv ).xyz;

	vec3 N = normalize( v_normal );
	if (normal_pixel != vec3(0,0,0))
	{
		N = perturbNormal(N, v_world_position, v_uv, normal_pixel);
	}

	FragColor = vec4( abs(N), 1.0 );
}

\uvs.fs

#version 330 core

in vec2 v_uv;

out vec4 FragColor;

void main()
{
	FragColor = vec4( v_uv, 1.0, 1.0 );
}

\shadowmap.fs

#version 330 core

in vec2 v_uv;

uniform sampler2D u_texture;
uniform float u_alpha_cutoff;

out vec4 FragColor;

void main()
{
	vec4 color = texture(u_texture, v_uv);

	//Check blending
	if (color.a < u_alpha_cutoff)
		discard;

	FragColor = vec4(1.0);
}

\testShadowmap

uniform sampler2D u_light_shadowmap;
uniform mat4 u_shadow_viewproj;
uniform int u_light_cast_shadows;
uniform float u_light_shadowbias;

float testShadowmap(vec3 pos)
{
	//project our 3D position to the shadowmap
	vec4 proj_pos = u_shadow_viewproj * vec4(pos, 1.0);

	//from homogeneus space to clip space
	vec2 shadow_uv = proj_pos.xy / proj_pos.w;

	//from clip space to uv space
	shadow_uv = shadow_uv * 0.5 + vec2(0.5);

	if( shadow_uv.x < 0.0 || shadow_uv.x > 1.0 || shadow_uv.y < 0.0 || shadow_uv.y > 1.0 ){
      	if (u_light_type == 2) {return 1.0;}
		else {return 0.0;}
	}

	//get point depth [-1 .. +1] in non-linear space
	float real_depth = (proj_pos.z - u_light_shadowbias) / proj_pos.w;

	//normalize from [-1..+1] to [0..+1] still non-linear
	real_depth = real_depth * 0.5 + 0.5;

	//it is before near or behind far plane
	if(real_depth < 0.0 || real_depth > 1.0)
		return 1.0;

	//read depth from depth buffer in [0..+1] non-linear
	float shadow_depth = texture( u_light_shadowmap, shadow_uv).x;

	//compute final shadow factor by comparing
	float shadow_factor = 1.0;

	//we can compare them, even if they are not linear
	if( shadow_depth < real_depth )
		shadow_factor = 0.0;

	return shadow_factor; 
}

\singlelight.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;
in vec4 v_color;

uniform vec4 u_color;
uniform sampler2D u_texture;
uniform float u_time;
uniform float u_alpha_cutoff;
uniform vec3 u_emissive;

const int MAX_LIGHTS = 10;

uniform vec3 u_ambient_light;
uniform vec3 u_light_position[MAX_LIGHTS];
uniform vec3 u_light_color[MAX_LIGHTS];
uniform vec3 u_light_direction[MAX_LIGHTS];

uniform float u_light_max_dist[MAX_LIGHTS];
uniform float u_light_intensity[MAX_LIGHTS];
uniform float u_light_cutoff[MAX_LIGHTS];
uniform float u_light_cone_exp[MAX_LIGHTS];

uniform int u_light_type[MAX_LIGHTS];
uniform int u_num_lights;

uniform sampler2D u_emissive_texture;
uniform sampler2D u_texture_metallic_roughness;
uniform sampler2D u_texture_normals;

#include "normal_func"

#define POINT 0
#define SPOT 1
#define DIRECTIONAL 2

out vec4 FragColor;

void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture( u_texture, v_uv );

	if(color.a < u_alpha_cutoff)
		discard;

	vec3 light = vec3(0.0);
	light += u_ambient_light;

	vec3 N = normalize( v_normal );
	
	//Emissive
	vec4 emissive = vec4( u_emissive, 1.0);
	vec4 emissive_color = texture(u_emissive_texture, v_uv);
	emissive *= emissive_color;

	for (int i = 0; i < MAX_LIGHTS; ++i)
	{
		if (i < u_num_lights)
		{
			if (u_light_type[i] == 2) //DIRECTIONAL
			{
				vec3 L = normalize(-u_light_direction[i]);

				float NdotL = clamp(dot(N,L), 0.0, 1.0);

				light += (NdotL * u_light_color[i]) * u_light_intensity[i];
			}
			else
			{
				vec3 L = u_light_position[i] - v_world_position;
				float light_dist = length(L);
				L = normalize(L);

				float att_factor = u_light_max_dist[i] - light_dist;
				att_factor /= u_light_max_dist[i];
				att_factor = max(att_factor, 0.0);
				att_factor *= pow(att_factor, 2.0);

				float NdotL = clamp(dot(N,L), 0.0, 1.0);

				if (u_light_type[i] == 0) //POINT
				{
					light += (NdotL * u_light_color[i]) * att_factor * u_light_intensity[i];
				}
				if (u_light_type[i] == 1) //SPOT
				{
					float cos_angle = dot(L, normalize(-u_light_direction[i]));

					if (cos_angle > u_light_cutoff[i])
					{
						float coneFactor = clamp(pow(cos_angle, u_light_cone_exp[i]), 0.0, 1.0);
						light += (NdotL * u_light_color[i]) * att_factor * u_light_intensity[i] * coneFactor;
					}
				}
			}
		}
	}
	color.xyz *= light;
	color.xyz += emissive.xyz;

	FragColor = color;
}


\multilight.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;
in vec4 v_color;

uniform vec4 u_color;
uniform sampler2D u_texture;
uniform float u_time;
uniform float u_alpha_cutoff;
uniform vec3 u_camera_position;

uniform vec3 u_ambient_light;
uniform vec3 u_light_position;
uniform vec3 u_light_color;
uniform vec3 u_light_direction;
uniform vec3 u_light_vector;

uniform float u_light_max_dist;
uniform float u_light_intensity;
uniform vec3 u_light_cone_exp;

uniform int u_light_type;

uniform sampler2D u_emissive_texture;
uniform sampler2D u_texture_normals;
uniform sampler2D u_roughness_texture;

uniform vec3 u_emissive;
uniform float u_roughness;
uniform float u_metallic;

uniform bool u_has_reflections;
uniform sampler2D u_reflections_texture;
uniform samplerCube u_skybox_texture;

out vec4 FragColor;

#define POINT 0
#define SPOT 1
#define DIRECTIONAL 2

#include "normal_func"
#include "getConeFactor"
#include "testShadowmap"
#include "PBR"

void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture( u_texture, v_uv );

	if(color.a < u_alpha_cutoff)
		discard;

	vec3 light = vec3(u_ambient_light);

	vec3 N = normalize( v_normal );
	vec3 L;

	//Emissive
	vec4 emissive = vec4( u_emissive, 1.0);
	vec4 emissive_color = texture(u_emissive_texture, v_uv);
	emissive *= emissive_color;

	float occlusion = texture(u_roughness_texture, v_uv).x;
	float roughness = texture(u_roughness_texture, v_uv).y;
	float metalness = texture(u_roughness_texture, v_uv).z;
	if (metalness == 1.0){ metalness = u_metallic;}
	if (roughness == 1.0){ roughness = u_roughness;}
	light *= occlusion;

	float shadow_factor = 1.0;
	float coneFactor = 1.0;
	float att_factor = 1.0;

	if (u_light_type == 2) //DIRECTIONAL
	{
		L = normalize(u_light_vector);
		
		if (u_light_cast_shadows == 1)
		{
			shadow_factor = testShadowmap(v_world_position);
		}
	}
	else
	{
		L = u_light_position - v_world_position;
		float light_dist = length(L);
		L = normalize(L);

		att_factor = u_light_max_dist - light_dist;
		att_factor /= u_light_max_dist;
		att_factor = max(att_factor, 0.0);
		att_factor *= pow(att_factor, 2.0);

		if (u_light_type == 1) //SPOT
		{	
			L = normalize(u_light_position - v_world_position);
			if (u_light_cone_exp.z > 0.0)
			{
				float cos_angle = dot(normalize(u_light_direction), -L);
				if (cos_angle > u_light_cone_exp.z)
				{
					coneFactor = pow(cos_angle, u_light_cone_exp.y);

					if (u_light_cast_shadows == 1)
					{
						shadow_factor = testShadowmap(v_world_position);
					}
				} else {coneFactor = 0.0;}
			} 
		}
	}
	vec3 V = normalize(u_camera_position - v_world_position);
	vec3 H = normalize(L+V);

	float NoL = clamp(dot(N,L),0.0, 1.0);
	float NoH = clamp(dot(N,H),0.0, 1.0);
	float NoV = clamp(dot(N,V),0.0, 1.0);
	float LoH = clamp(dot(L,H),0.0, 1.0);

	//we compute the reflection in base to the color and the metalness
	vec3 f0 = mix( vec3(0.5), color.xyz, metalness );

	//metallic materials do not have diffuse
	vec3 diffuseColor = (1.0 - metalness) * color.xyz;

	//compute the specular
	vec3 Fr_d = specularBRDF( roughness, f0, NoH, NoV, NoL, LoH);

	// Here we use the Burley, but you can replace it by the Lambert.
	float linearRoughness = pow(roughness, 2.0);
	vec3 Fd_d = diffuseColor * Fd_Burley(NoV,NoL,LoH,linearRoughness); 

	//add diffuse and specular reflection
	vec3 direct = Fr_d + Fd_d;

	//compute how much light received the pixel
	vec3 lightParams = (NoL * u_light_color) * u_light_intensity * att_factor * shadow_factor * coneFactor;

	//modulate direct light by light received
	light += direct * lightParams;

	color.xyz *= light;
	color.xyz += emissive.xyz;

	//REFLECTION
	vec3 material = texture(u_roughness_texture, v_uv).xyz;
	vec3 R = reflect(-V, N);
	vec3 reflection = texture(u_skybox_texture, R).xyz;

	//float reflection_factor = material.z; //METAL
	//color.xyz = reflection;
	//color.xyz += mix(color.xyz, reflection, reflection_factor);

	FragColor = color;
}

\gbuffers.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;
in vec4 v_color;

uniform vec4 u_color;
uniform float u_time;
uniform float u_alpha_cutoff;

uniform sampler2D u_texture;
uniform sampler2D u_emissive_texture;
uniform sampler2D u_texture_normals;
uniform sampler2D u_roughness_texture;

uniform vec3 u_emissive;
uniform float u_roughness;
uniform float u_metallic;

layout(location = 0) out vec4 GB0;
layout(location = 1) out vec4 GB1;
layout(location = 2) out vec4 GB2;

#include "normal_func"
#include "linear_space"

//from https://github.com/hughsk/glsl-dither/blob/master/4x4.glsl
float dither4x4(vec2 position, float brightness)
{
  int x = int(mod(position.x, 4.0));
  int y = int(mod(position.y, 4.0));
  int index = x + y * 4;
  float limit = 0.0;

  if (x < 8) {
    if (index == 0) limit = 0.0625;
    if (index == 1) limit = 0.5625;
    if (index == 2) limit = 0.1875;
    if (index == 3) limit = 0.6875;
    if (index == 4) limit = 0.8125;
    if (index == 5) limit = 0.3125;
    if (index == 6) limit = 0.9375;
    if (index == 7) limit = 0.4375;
    if (index == 8) limit = 0.25;
    if (index == 9) limit = 0.75;
    if (index == 10) limit = 0.125;
    if (index == 11) limit = 0.625;
    if (index == 12) limit = 1.0;
    if (index == 13) limit = 0.5;
    if (index == 14) limit = 0.875;
    if (index == 15) limit = 0.375;
  }

  return brightness < limit ? 0.0 : 1.0;
}

void main()
{
	vec3 N = normalize(v_normal);

	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture(u_texture, v_uv);

	if (color.a < u_alpha_cutoff && dither4x4(gl_FragCoord.xy, color.a) == 0.0)
		discard;

	vec3 emissive = u_emissive * texture(u_emissive_texture, v_uv).xyz;

	float occlusion = texture(u_roughness_texture, v_uv).x;
	float roughness = texture(u_roughness_texture, v_uv).y;
	float metalness = texture(u_roughness_texture, v_uv).z;
	if (metalness == 1.0){ metalness = u_metallic;}
	if (roughness == 1.0){ roughness = u_roughness;}

	GB0 = vec4(color.xyz, occlusion);
	GB1 = vec4(N * 0.5 + vec3(0.5), roughness);
	GB2 = vec4(emissive, metalness);
}

\deferred.fs

#version 330 core

in vec2 v_uv;

uniform sampler2D u_gb0_texture;
uniform sampler2D u_gb1_texture;
uniform sampler2D u_gb2_texture;
uniform sampler2D u_depth_texture;
uniform sampler2D u_ssao_texture;

uniform mat4 u_inverse_viewprojection;
uniform vec2 u_iRes;

uniform float u_time;
uniform float u_alpha_cutoff;
uniform float u_light_intensity;
uniform float u_light_max_dist;

uniform int u_light_type;
uniform vec3 u_light_color;
uniform vec3 u_light_position;
uniform vec3 u_light_cone_exp;
uniform vec3 u_light_vector;
uniform vec3 u_light_direction;
uniform vec3 u_ambient_light;
uniform vec3 u_camera_position;

uniform sampler2D u_irr_texture;
uniform vec3 u_irr_start;
uniform vec3 u_irr_end;
uniform vec3 u_irr_dim;

uniform float u_irr_normal_distance;
uniform float u_num_probes;
uniform vec3 u_irr_delta;
uniform bool u_irr;

out vec4 FragColor;

#define POINT 0
#define SPOT 1
#define DIRECTIONAL 2

#include "getConeFactor"
#include "testShadowmap"
#include "PBR"
#include "linear_space"
#include "SH"
#include "irradiance"

void main()
{
	vec2 uv = gl_FragCoord.xy * u_iRes.xy;
	
	vec4 gb0_color = texture(u_gb0_texture, uv); //Color
	vec4 gb1_color = texture(u_gb1_texture, uv); //Normal
	vec4 gb2_color = texture(u_gb2_texture, uv); //Extra

	vec3 occ_met_roug = vec3(gb0_color.w, gb1_color.w, gb2_color.w);

	float occlusion = occ_met_roug.x;
	float roughness = occ_met_roug.y;
	float metalness = occ_met_roug.z;

	float depth = texture (u_depth_texture, uv).x;
	if (depth == 1.0) discard;
	vec4 screen_pos = vec4(uv.x * 2.0 - 1.0, uv.y * 2.0 - 1.0, depth * 2.0 - 1.0, 1.0);
	vec4 proj_worldpos = u_inverse_viewprojection * screen_pos;
	vec3 world_position = proj_worldpos.xyz / proj_worldpos.w;

	vec3 N = normalize(gb1_color.xyz * 2.0 - vec3(1.0));
	vec4 color = vec4(degamma(gb0_color.xyz), 1.0);
	if(color.a < u_alpha_cutoff) discard;

	//SSAO +
	float ao_factor = texture(u_ssao_texture, uv).x;
	ao_factor *= pow(ao_factor, 2.0);

	vec3 ambient = u_ambient_light * ao_factor;

	//IRRADIANCE
	vec3 irradiance = vec3(1.0);
	if (u_irr)
		irradiance = computeIrradiance(u_irr_end, u_irr_start, world_position, N, u_irr_normal_distance, u_irr_delta, u_irr_dim, u_num_probes, u_irr_texture);
	
	vec3 L;
	float shadow_factor = 1.0;
	float coneFactor = 1.0;
	float att_factor = 1.0;

	if (u_light_type == 2) //DIRECTIONAL
	{
		L = normalize(u_light_vector);
		if (u_light_cast_shadows == 1)
		{
			shadow_factor = testShadowmap(world_position);
		}
	}
	else
	{
		L = normalize(u_light_position - world_position);
		float light_dist = length(u_light_position - world_position);

		att_factor = u_light_max_dist - light_dist;
		att_factor /= u_light_max_dist;
		att_factor = max(att_factor, 0.0);
		att_factor *= pow(att_factor, 2.0);

		if (u_light_type == 1) //SPOT
		{	
			if (u_light_cone_exp.z > 0.0)
			{
				float cos_angle = dot(normalize (u_light_direction), -L);
				if (cos_angle >= u_light_cone_exp.z)
				{
					coneFactor = pow(cos_angle, u_light_cone_exp.y);

					if (u_light_cast_shadows == 1)
					{
						shadow_factor = testShadowmap(world_position);
					}
				}else{coneFactor = 0.0;} 
			} 
		}
	}

	vec3 V = normalize(u_camera_position - world_position);
	vec3 H = normalize(L+V);

	float NoL = clamp(dot(N,L),0.0, 1.0);
	float NoH = clamp(dot(N,H),0.0, 1.0);
	float NoV = clamp(dot(N,V),0.0, 1.0);
	float LoH = clamp(dot(L,H),0.0, 1.0);

	//we compute the reflection in base to the color and the metalness
	vec3 f0 = mix( vec3(0.5), color.xyz, metalness);

	//metallic materials do not have diffuse
	vec3 diffuseColor = (1.0 - metalness) * color.xyz;

	//compute the specular
	vec3 Fr_d = specularBRDF( roughness, f0, NoH, NoV, NoL, LoH);

	// Here we use the Burley, but you can replace it by the Lambert.
	float linearRoughness = pow(roughness, 2.0);
	vec3 Fd_d = diffuseColor * Fd_Burley(NoV,NoL,LoH,linearRoughness);

	//add diffuse and specular reflection
	vec3 direct = Fr_d + Fd_d;

	//compute how much light received the pixel
	vec3 lightParams = u_light_color * u_light_intensity * att_factor * shadow_factor * coneFactor;

	//modulate direct light by light received
	vec3 light = direct * lightParams + ambient;

	color.xyz *= light;
	color.xyz += gb2_color.xyz;

	FragColor = color;
}


\ssao.fs

#version 330 core

in vec2 v_uv;

uniform sampler2D u_gb1_texture;
uniform sampler2D u_depth_texture;

uniform mat4 u_viewprojection;
uniform mat4 u_inverse_viewprojection;
uniform vec2 u_iRes;
uniform vec3 u_points[64];

out vec4 FragColor;

void main()
{
	vec2 uv = gl_FragCoord.xy * u_iRes.xy;

	float depth = texture (u_depth_texture, uv).x;

	//ignore if pixels in the background
	if(depth >= 1.0)
	{
		FragColor = vec4(1.0);
		return;
	}

	vec4 screen_pos = vec4(uv.x*2.0-1.0, uv.y*2.0-1.0, depth*2.0-1.0, 1.0);
	vec4 proj_worldpos = u_inverse_viewprojection * screen_pos;
	vec3 worldpos = proj_worldpos.xyz / proj_worldpos.w;

	//lets use 64 samples
	const int samples = 64;
	int num = samples; //num samples that passed the are outside

	//for every sample around the point
	for( int i = 0; i < samples; ++i )
	{
		//compute is world position using the random
		vec3 p = worldpos + u_points[i] * 10.0;
		//find the uv in the depth buffer of this point
		vec4 proj = u_viewprojection * vec4(p,1.0);
		proj.xy /= proj.w; //convert to clipspace from homogeneous
		//apply a tiny bias to its z before converting to clip-space
		proj.z = (proj.z - 0.005) / proj.w;
		proj.xyz = proj.xyz * 0.5 + vec3(0.5); //to [0..1]
		//read p true depth
		float pdepth = texture( u_depth_texture, proj.xy ).x;
		//compare true depth with its depth
		float diff = proj.z - pdepth;
		if( diff > 0.0 && diff < 0.001) //if true depth smaller, is inside
			num--; //remove this point from the list of visible
	}

	//finally, compute the AO factor as the ratio of visible points
	float ao = float(num) / float(samples);

	FragColor = vec4(ao);
}

\ssao_plus.fs

#version 330 core

in vec2 v_uv;

uniform sampler2D u_gb1_texture;
uniform sampler2D u_depth_texture;

uniform mat4 u_viewprojection;
uniform mat4 u_inverse_viewprojection;
uniform vec2 u_iRes;
uniform vec3 u_points[64];

layout(location = 0) out vec4 FragColor;

#include "normal_func"

void main()
{
	vec2 uv = gl_FragCoord.xy * u_iRes.xy;

	float depth = texture (u_depth_texture, uv).x;

	//ignore if pixels in the background
	if(depth >= 1.0)
	{
		FragColor = vec4(1.0);
		return;
	}

	vec4 screen_pos = vec4(uv.x*2.0-1.0, uv.y*2.0-1.0, depth*2.0-1.0, 1.0);
	vec4 proj_worldpos = u_inverse_viewprojection * screen_pos;
	vec3 worldpos = proj_worldpos.xyz / proj_worldpos.w;

	//lets use 64 samples
	const int samples = 64;
	int num = samples; //num samples that passed the are outside

	//SSAO_PLUS
	vec4 gb1_color = texture(u_gb1_texture, uv); //Normal
	vec3 N = normalize(gb1_color.xyz * 2.0 - vec3(1.0));
	mat3 rotmat = cotangent_frame(gb1_color.xyz, worldpos, uv);

	//for every sample around the point
	for( int i = 0; i < samples; ++i )
	{
		//compute is world position using the random
		vec3 p = worldpos + u_points[i] * 10.0;
		//find the uv in the depth buffer of this point
		vec4 proj = u_viewprojection * vec4(p,1.0);
		proj.xy /= proj.w; //convert to clipspace from homogeneous
		//apply a tiny bias to its z before converting to clip-space
		proj.z = (proj.z - 0.005) / proj.w;
		proj.xyz = proj.xyz * 0.5 + vec3(0.5); //to [0..1]
		//read p true depth
		float pdepth = texture( u_depth_texture, proj.xy ).x;
		//compare true depth with its depth
		float diff = proj.z - pdepth;
		if( diff > 0.0 && diff < 0.001) //if true depth smaller, is inside
			num--; //remove this point from the list of visible
	}

	//finally, compute the AO factor as the ratio of visible points
	float ao = float(num) / float(samples);

	FragColor = vec4(ao);
}

\ssao_blur.fs

#version 330 core

in vec2 v_uv;
uniform sampler2D u_ssao_texture;
uniform float weight[5] = float[] (0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216);

out vec4 FragColor;

void main() {
	
	 vec3 result = texture(u_ssao_texture, v_uv).rgb * weight[0];
	 vec2 size = 1.0 / textureSize(u_ssao_texture, 0);

	 for(int i = 1; i < 5; ++i){
            result += texture(u_ssao_texture, v_uv + vec2(size.x * i, 0.0)).rgb * weight[i];
            result += texture(u_ssao_texture, v_uv - vec2(size.x * i, 0.0)).rgb * weight[i];
	}
	FragColor = vec4(result, 1.0);
} 


\tonemapping.fs

#version 330 core

in vec2 v_uv;

uniform sampler2D u_texture;

uniform float u_scale;
uniform float u_average_lum;
uniform float u_lumwhite2;
uniform float u_igamma;

#include "linear_space"

void main() {
	vec4 color = texture2D( u_texture, v_uv );
	vec3 rgb = color.xyz;

	float lum = dot(rgb, vec3(0.2126, 0.7152, 0.0722));
	float L = (u_scale / u_average_lum) * lum;
	float Ld = (L * (1.0 + L / u_lumwhite2)) / (1.0 + L);

	rgb = (rgb / lum) * Ld;
	rgb = max(rgb,vec3(0.001));
	rgb = pow( rgb, vec3( 1.0 / u_igamma ) );
	gl_FragColor = vec4( rgb, color.a );
}

\probe.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;
in vec4 v_color;

uniform vec3 u_coeffs[9];

out vec4 FragColor;

#include "SH"

void main()
{
	SH9Color sh;
	sh.c[0] = u_coeffs[0];
	sh.c[1] = u_coeffs[1];
	sh.c[2] = u_coeffs[2];
	sh.c[3] = u_coeffs[3];
	sh.c[4] = u_coeffs[4];
	sh.c[5] = u_coeffs[5];
	sh.c[6] = u_coeffs[6];
	sh.c[7] = u_coeffs[7];
	sh.c[8] = u_coeffs[8];

	vec3 N = normalize(v_normal);
	vec3 irradiance = ComputeSHIrradiance( N, sh );
	FragColor = vec4(irradiance, 1.0);
}

\irradiance.fs

#version 330 core

uniform vec2 u_iRes;

uniform sampler2D u_gb0_texture;
uniform sampler2D u_gb1_texture;
uniform sampler2D u_depth_texture;

uniform mat4 u_inverse_viewprojection;
uniform mat4 u_viewprojection;

uniform sampler2D u_irr_texture;
uniform vec3 u_irr_start;
uniform vec3 u_irr_end;
uniform vec3 u_irr_dim;

uniform float u_irr_normal_distance;
uniform float u_num_probes;
uniform vec3 u_irr_delta;

out vec4 FragColor;

#include "SH"
#include "irradiance"

void main()
{
	vec2 uv = gl_FragCoord.xy * u_iRes.xy;
	
	float depth = texture(u_depth_texture, uv).x;	
	vec4 gb1_color = texture(u_gb1_texture, uv);
	vec3 N = normalize(gb1_color.xyz * 2.0 - vec3(1.0));

	if(depth >= 1.0){
		FragColor = vec4(1.0);
		return;
	}

	vec4 screen_pos = vec4(uv.x * 2.0 - 1.0, uv.y * 2.0 - 1.0, depth * 2.0 - 1.0, 1.0);
	vec4 proj_worldpos = u_inverse_viewprojection * screen_pos;
	vec3 world_position = proj_worldpos.xyz / proj_worldpos.w;

	//computing nearest probe index based on world position
	vec3 irr_range = u_irr_end - u_irr_start; 
	vec3 irr_local_pos = clamp(world_position - u_irr_start + N * u_irr_normal_distance, vec3(0.0), irr_range);

	//convert from world pos to grid pos
	vec3 irr_norm_pos = irr_local_pos / u_irr_delta;

	//round values as we cannot fetch between rows for now
	vec3 local_indices = round(irr_norm_pos);

	//compute in which row is the probe stored
	float row = local_indices.x + local_indices.y * u_irr_dim.x + local_indices.z * u_irr_dim.x * u_irr_dim.y;

	//find the UV.y coord of that row in the probes texture
	float row_uv = (row + 1.0) / (u_num_probes + 1.0);

	SH9Color sh;

	//fill the coefficients
	const float d_uvx = 1.0 / 9.0;
	for(int i = 0; i < 9; i++) {
		vec2 coeffs_uv = vec2((float(i)+0.5) * d_uvx, row_uv);
		sh.c[i] = texture(u_irr_texture, coeffs_uv).xyz;
	}

	//now we can use the coefficients to compute the irradiance
	vec3 irradiance = ComputeSHIrradiance(N, sh);
	vec3 color = texture(u_gb0_texture, uv).xyz * irradiance;
	FragColor = vec4(color, 1.0);
}

\skybox.fs

#version 330 core

in vec3 v_world_position;

uniform samplerCube u_texture;
uniform vec3 u_camera_position;

out vec4 FragColor;

void main()
{
	vec3 V = v_world_position - u_camera_position;
	FragColor = texture(u_texture, V);
}

\reflection_probe.fs

#version 330 core

in vec3 v_world_position;
in vec3 v_normal;

uniform samplerCube u_texture;
uniform vec3 u_camera_position;

out vec4 FragColor;

void main()
{
	vec3 V = v_world_position - u_camera_position;
	vec3 N = normalize(v_normal);
	vec3 R = reflect(V, N);
	FragColor = texture(u_texture, R);
}

\volumetric.fs

#version 330 core

uniform vec2 u_iRes;

uniform sampler2D u_depth_texture;
uniform mat4 u_inverse_viewprojection;
uniform mat4 u_viewprojection;
uniform vec3 u_camera_position;
uniform vec3 u_ambient_light;
uniform vec3 u_light_color;
uniform vec3 u_light_position;
uniform int u_light_type;
uniform float u_air_density;

uniform vec3 u_light_vector;
uniform float u_light_max_dist;
uniform vec3 u_light_direction;
uniform vec3 u_light_cone_exp;

out vec4 FragColor;

const int SAMPLES = 64;

#include "SH"
#include "testShadowmap"

void main()
{
	vec2 uv = gl_FragCoord.xy * u_iRes.xy;
	
	float depth = texture(u_depth_texture, uv).x;	

	vec4 screen_pos = vec4(uv.x * 2.0 - 1.0, uv.y * 2.0 - 1.0, depth * 2.0 - 1.0, 1.0);
	vec4 proj_worldpos = u_inverse_viewprojection * screen_pos;
	vec3 world_position = proj_worldpos.xyz / proj_worldpos.w;
	vec3 color = vec3(0.0);

	vec3 ray_start = u_camera_position;
	vec3 ray_dir = (world_position - ray_start);
	float ray_length = length(ray_dir);
	ray_dir /= ray_length;
	ray_dir = normalize(ray_dir);
	ray_length = min(500.0, ray_length);
	
	float step_dist = ray_length / float(SAMPLES);

	vec3 current_pos = ray_start;
	vec3 ray_offset = ray_dir * step_dist;

	float transparency = 1.0;
	vec3 irradiance = vec3(0.0);

	vec3 L;
	if (u_light_type == 2)
		L = normalize(u_light_vector);
	else
		L = u_light_position - world_position;

	float light_dist = length(L);
	float att_factor = u_light_max_dist - light_dist;
	float coneFactor = 1.0;

	if (u_light_type == 1) //SPOT
	{	
		L = normalize(u_light_position - world_position);
		if (u_light_cone_exp.z > 0.0)
		{
			float cos_angle = dot(normalize(u_light_direction), -L);
			if (cos_angle > u_light_cone_exp.z)
			{
				coneFactor = pow(cos_angle, u_light_cone_exp.y);

			} else {coneFactor = 0.0;}
		} 
	}
	att_factor /= u_light_max_dist;
	att_factor = max(att_factor, 0.0);
	att_factor *= pow(att_factor, 2.0);

	for(int i = 0; i < SAMPLES; ++i)
	{
		vec3 light = u_light_color * testShadowmap(current_pos);

		irradiance += light * transparency * (u_air_density * step_dist);

		transparency -= u_air_density * step_dist;

		if( transparency < 0.001 )
			break;

		//advance to next position
		current_pos.xyz += ray_offset;
	}
	FragColor = vec4(irradiance, 1.0 - transparency);
}

\decal.fs

#version 330 core

uniform mat4 u_inverse_viewprojection;
uniform mat4 u_viewprojection;
uniform vec2 u_iRes;
uniform vec3 u_camera_position;

uniform sampler2D u_depth_texture;
uniform sampler2D u_decal_texture;

uniform mat4 u_imodel;

out vec4 FragColor;

void main()
{
	vec2 uv = gl_FragCoord.xy * u_iRes.xy;
	
	float depth = texture(u_depth_texture, uv).x;

	vec4 screen_pos = vec4(uv.x * 2.0 - 1.0, uv.y * 2.0 - 1.0, depth * 2.0 - 1.0, 1.0);
	vec4 proj_worldpos = u_inverse_viewprojection * screen_pos;
	vec3 worldpos = proj_worldpos.xyz / proj_worldpos.w;

	vec3 localpos = (u_imodel * vec4(worldpos, 1.0)).xyz;

	if(		localpos.x < -0.5 || localpos.x > 0.5 ||  
			localpos.y < -0.5 || localpos.y > 0.5 || 
			localpos.z < -0.5 || localpos.z > 0.5)
			discard;

	vec2 decal_uv = localpos.xz + vec2(0.5);
	vec4 color = texture(u_decal_texture, decal_uv);

	FragColor = color;
}

//POSTFX

\greyscale.fs

#version 330 core

in vec2 v_uv;

uniform sampler2D u_texture;

uniform float u_vigneting;
uniform float u_saturation;

layout(location = 0) out vec4 FragColor;

void main()
{
	vec4 color = texture(u_texture, v_uv);
	vec3 desaturated = vec3((color.x + color.y + color.z)/3.0);
	color.xyz = mix( desaturated, color.xyz, u_saturation);

	vec3 vigneting = color.xyz * pow(1.2 - length(v_uv - vec2(0.5, 0.5)), 4.0);
	color.xyz = mix(color.xyz, vigneting, u_vigneting);

	FragColor = color;
}

\contrast.fs

#version 330 core

in vec2 v_uv;

uniform sampler2D u_texture;
uniform float u_intensity;

out vec4 FragColor;

void main()
{
	vec2 uv = v_uv;
	vec4 color = texture(u_texture, uv);
	color.xyz = (color.xyz - vec3(0.5)) * u_intensity + vec3(0.5);

	FragColor = color;
}

\blur.fs

#version 330 core

precision highp float;
varying vec2 v_uv;
uniform sampler2D u_texture;
uniform vec2 u_offset;
uniform float u_intensity;

void main() {
   vec4 sum = vec4(0.0);
   sum += texture2D(u_texture, v_uv + u_offset * -4.0) * 0.05/0.98;
   sum += texture2D(u_texture, v_uv + u_offset * -3.0) * 0.09/0.98;
   sum += texture2D(u_texture, v_uv + u_offset * -2.0) * 0.12/0.98;
   sum += texture2D(u_texture, v_uv + u_offset * -1.0) * 0.15/0.98;
   sum += texture2D(u_texture, v_uv) * 0.16/0.98;
   sum += texture2D(u_texture, v_uv + u_offset * 4.0) * 0.05/0.98;
   sum += texture2D(u_texture, v_uv + u_offset * 3.0) * 0.09/0.98;
   sum += texture2D(u_texture, v_uv + u_offset * 2.0) * 0.12/0.98;
   sum += texture2D(u_texture, v_uv + u_offset * 1.0) * 0.15/0.98;
   gl_FragColor = u_intensity * sum;
}

\mix.fs

#version 330 core

precision highp float;
varying vec2 v_uv;
uniform sampler2D u_texture;
uniform sampler2D u_textureB;
uniform float u_intensity;

void main() {
	vec4 colorA = texture2D(u_texture, v_uv);
	vec4 colorB = texture2D(u_textureB, v_uv);

	gl_FragColor = colorA * u_intensity + colorB;
}

\threshold.fs

#version 330 core

precision highp float;
varying vec2 v_uv;
uniform sampler2D u_texture;
uniform float u_threshold;

void main() {
   vec4 color = texture(u_texture, v_uv);
	if(color.x < u_threshold) 
		color.x = 0.0;
	if(color.y < u_threshold) 
		color.y = 0.0;
	if(color.z < u_threshold) 
		color.z = 0.0;

   gl_FragColor = color;
}

\dof.fs

#version 330 core

uniform vec2 u_iRes;
uniform vec2 u_camera_nearfar;

uniform float u_size;
uniform float u_aperture;
uniform float u_focal_length;
uniform float u_plane_focus;

uniform sampler2D u_depth_texture;
uniform sampler2D u_texture;

#include "blurtex"

out vec4 FragColor;

// Circle of Confusion from https://developer.nvidia.com/gpugems/gpugems/part-iv-image-processing/chapter-23-depth-field-survey-techniques
// Clamp 20 from https://fileadmin.cs.lth.se/cs/Education/EDAN35/lectures/12DOF.pdf
void main()
{
	// Normalized pixel coordinates (from 0 to 1)
  	vec2 uv = gl_FragCoord.xy * u_iRes;

	float z = texture( u_depth_texture, uv ).x;

	float n = u_camera_nearfar.x;
	float f = u_camera_nearfar.y;
	float object_distance = n * (z + 1.0) / (f + n - z * (f - n));
	float CoC = abs(u_aperture * (u_focal_length * (object_distance - u_plane_focus)) / (object_distance * (u_plane_focus - u_focal_length)) );
	
	CoC = clamp(CoC, 0.0, 20.0);

	vec4 blurred_color = blur_texture(u_texture, u_iRes, CoC);
    FragColor = blurred_color;
}

\bloom.fs

#version 330 core
  
in vec2 v_uv;

uniform float threshold;
uniform float soft_threshold;
uniform float u_intensity;

uniform sampler2D u_texture;

out vec4 FragColor;

// https://catlikecoding.com/unity/tutorials/advanced-rendering/bloom/
void main()
{
	//we want to center the sample in the center of the pixel
	vec2 uv = v_uv;
	vec3 c = texture(u_texture, uv).rgb * u_intensity;

	float brightness = max(c.r, max(c.g, c.b));
	float knee = threshold * soft_threshold;
	float soft = brightness - threshold + knee;
	soft = clamp(soft, 0, 2 * knee);
	soft = soft * soft / (4 * knee + 0.00001);

	float contribution = max(soft, brightness - threshold);
	contribution /= max(brightness, 0.01);
	FragColor = vec4(c * contribution, 1.0);
}

\fxaa.fs

#version 330 core

uniform vec2 u_viewportSize;
uniform vec2 u_iViewportSize;
uniform sampler2D u_texture;

#define FXAA_REDUCE_MIN (1.0/ 128.0)
#define FXAA_REDUCE_MUL (1.0 / 8.0)
#define FXAA_SPAN_MAX 8.0

out vec4 FragColor;

void main()
{
	vec2 fragCoord = gl_FragCoord.xy;
	vec4 color = vec4(0.0);
	/*vec2 u_iViewportSize = vec2(1.0 / u_viewportSize.x, 1.0 / u_viewportSize.y);*/
	vec3 rgbNW = texture2D(u_texture, (fragCoord + vec2(-1.0, -1.0)) * u_iViewportSize).xyz;
	vec3 rgbNE = texture2D(u_texture, (fragCoord + vec2(1.0, -1.0)) * u_iViewportSize).xyz;
	vec3 rgbSW = texture2D(u_texture, (fragCoord + vec2(-1.0, 1.0)) * u_iViewportSize).xyz;
	vec3 rgbSE = texture2D(u_texture, (fragCoord + vec2(1.0, 1.0)) * u_iViewportSize).xyz;
	vec3 rgbM  = texture2D(u_texture, fragCoord  * u_iViewportSize).xyz;
	vec3 luma = vec3(0.299, 0.587, 0.114);
	float lumaNW = dot(rgbNW, luma);
	float lumaNE = dot(rgbNE, luma);
	float lumaSW = dot(rgbSW, luma);
	float lumaSE = dot(rgbSE, luma);
	float lumaM  = dot(rgbM,  luma);
	float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
	float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));
	
	vec2 dir;
	dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
	dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));
	
	float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);
	
	float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
	dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX), dir * rcpDirMin)) * u_iViewportSize;
	
	vec3 rgbA = 0.5 * (texture2D(u_texture, fragCoord * u_iViewportSize + dir * (1.0 / 3.0 - 0.5)).xyz + 
		texture2D(u_texture, fragCoord * u_iViewportSize + dir * (2.0 / 3.0 - 0.5)).xyz);
	vec3 rgbB = rgbA * 0.5 + 0.25 * (texture2D(u_texture, fragCoord * u_iViewportSize + dir * -0.5).xyz + 
		texture2D(u_texture, fragCoord * u_iViewportSize + dir * 0.5).xyz);
	
	//return vec4(rgbA,1.0);
	float lumaB = dot(rgbB, luma);
	if ((lumaB < lumaMin) || (lumaB > lumaMax))
		color = vec4(rgbA, 1.0);
	else
		color = vec4(rgbB, 1.0);
	
	FragColor = color;
}

\lut.fs

#version 330 core

in vec2 v_uv;

precision highp float;
precision highp float;
varying vec2 v_coord;
uniform sampler2D u_texture;
uniform sampler2D u_textureB;
uniform float u_amount;

void main() {
	 lowp vec4 color = clamp( texture2D(u_texture, v_coord), vec4(0.0), vec4(1.0) );
	 mediump float blueColor = color.b * 63.0;
	 mediump vec2 quad1;
	 quad1.y = floor(floor(blueColor) / 8.0);
	 quad1.x = floor(blueColor) - (quad1.y * 8.0);
	 mediump vec2 quad2;
	 quad2.y = floor(ceil(blueColor) / 8.0);
	 quad2.x = ceil(blueColor) - (quad2.y * 8.0);
	 highp vec2 texPos1;
	 texPos1.x = (quad1.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * color.r);
	 texPos1.y = 1.0 - ((quad1.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * color.g ));
	 highp vec2 texPos2;
	 texPos2.x = (quad2.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * color.r);
	 texPos2.y = 1.0 - ((quad2.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * color.g));
	 lowp vec4 newColor1 = texture2D(u_textureB, texPos1);
	 lowp vec4 newColor2 = texture2D(u_textureB, texPos2);
	 lowp vec4 newColor = mix(newColor1, newColor2, fract(blueColor));
	 gl_FragColor = vec4( mix( color.rgb, newColor.rgb, u_amount), color.w);
}

\lens_distortion.fs

#version 330 core

in vec2 v_uv;

uniform vec2 u_iRes;
uniform sampler2D u_texture;
uniform float u_resolution;

out vec4 FragColor;

void main() 
{
	vec2 p = gl_FragCoord.xy * u_iRes.x; 
	float prop = u_iRes.y / u_iRes.x;
	vec2 m = vec2(0.5, 0.5 / prop);
	vec2 d = p - m;
	float r = sqrt(dot(d, d)); 

	float resolution = sin(u_resolution * 2.0);

	float bind = sqrt(dot(m, m));

	vec2 uv;
	if (resolution > 0.0)//fisheye
		uv = m + normalize(d) * tan(r * resolution) * bind / tan( bind * resolution);
	else if (resolution < 0.0)
		uv = m + normalize(d) * atan(r * - resolution) * bind / atan(-resolution * bind);
	else uv = p;
        
	uv.y *= prop;
	vec3 color = texture(u_texture, uv).rgb;
    
	FragColor = vec4(color, 1.0);
}

\chromatic_aberration.fs

#version 330 core

uniform sampler2D u_texture;
uniform vec2 u_iRes;
uniform float u_amount;

out vec4 FragColor;

void main()
{
    vec2 uv = gl_FragCoord.xy * u_iRes.xy;
	
    vec3 col;
    col.r = texture( u_texture, vec2(uv.x+u_amount,uv.y) ).r;
    col.g = texture( u_texture, uv ).g;
    col.b = texture( u_texture, vec2(uv.x-u_amount,uv.y) ).b;

	col *= (1.0 - u_amount * 0.5);
	
    FragColor = vec4(col,1.0);
}

\motionblur.fs

#version 330 core

precision highp float;
varying vec2 v_uv;
uniform sampler2D u_texture;
uniform sampler2D u_depth_texture;

uniform mat4 u_viewprojection_old;
uniform mat4 u_inverse_viewprojection;

void main() {
	vec2 uv = v_uv;
	
	float depth = texture(u_depth_texture, uv).x;
	vec4 screen_pos = vec4(uv.x * 2.0 - 1.0, uv.y * 2.0 - 1.0, depth * 2.0 - 1.0, 1.0);
	vec4 proj_worldpos = u_inverse_viewprojection * screen_pos;
	vec3 world_position = proj_worldpos.xyz / proj_worldpos.w;

	vec4 oldpos2d = u_viewprojection_old * vec4(world_position, 1.0);
	oldpos2d.xyz /= oldpos2d.w;
	vec2 uv2 = oldpos2d.xy * 0.5 + vec2(0.5);

	vec4 color = vec4(0.0);
	const int SAMPLES = 16;

	for(int i = 0; i < SAMPLES; i++)
	{
		float f = float(i) / float(SAMPLES);
		vec2 interpolated_uv = mix(uv, uv2, f);
		color += texture2D(u_texture, interpolated_uv);
	}

	color /= float(SAMPLES);

	gl_FragColor = color;
}

\grain.fs

#version 330 core

in vec2 v_uv;

uniform float amount;
uniform sampler2D tDiffuse;
uniform float noise_amount;

float random( vec2 p )
{
	vec2 K1 = vec2(
    		23.14069263277926, // e^pi (Gelfond's constant)
    		2.665144142690225 // 2^sqrt(2) (Gelfond–Schneider constant)
  		);
	return fract( cos( dot(p,K1) ) * 12345.6789 );
}

void main() {
	vec2 vUv = v_uv;

  	vec4 color = texture( tDiffuse, vUv );
  	vec2 uvRandom = vUv;
 	uvRandom.y *= random(vec2(uvRandom.y,amount));
  	color.rgb += random(uvRandom)*0.05 * noise_amount;
  	gl_FragColor = vec4( color );
}